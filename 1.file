
Page
3
of 9
COM SCI 118 Spring 2022
Project 2: Simple Window-Based Reliable Data Transfer
Due date: June 3th, 23:59 PT
1 Overview
The purpose of this project is to implement a basic version of reliable data transfer protocol. You will design
a new customized reliable data transfer protocol, akin to TCP but using UDP in C/C++ programming
language. This project will deepen your understanding on how TCP protocol works and specifically how it
handles packet losses.
You will implement this protocol in context of server and client applications, where client transmits a
file as soon as the connection is established. We will provide skeleton code for connection management. The
following functions should be realized:
•Large file transmission with pipelining.
•Loss recovery with Go-Back-N (GBN) or Selective Repeat (SR). If you implement SR, you can get up
to 15% bonus. Implementation with GBN will not get the bonus.
We made several simplifications to the real TCP protocol, especially:
•You do not need to implement checksum computation and/or verification;
•You can assume there are no corruption, no reordering, and no duplication of the packets in transmit;
The only unreliability you will work on is packet loss;
•You do not need to estimate RTT, nor to update RTO using RTT estimation or using Karn’s algorithm
to double it; You will use a fixed retransmission timer value;
•You do not need to handle parallel connections; all connections are assumed sequential.
•You do not need to realize congestion control in your project.
We require you implement code in a Linux environment so we can test it with simulated packet loss.
All implementations need to be written in C/C++ using BSD sockets. You are not allowed to use any
third-party libraries (like Boost.Asio or similar) other than the standard libraries provided by C/C++. You
are allowed to use some high-level abstractions, including C++14 extensions, for parts that are not directly
related to networking, such as string parsing and multi-threading.
2 Instructions
The project contains two parts: a server and a client.
•The server opens UDP socket and implements incoming connection management from clients. For each
of the connection, the server saves all the received data from the client in a file.
•The client opens UDP socket, implements outgoing connection management, and connects to the server.
Once connection is established, it sends the content of a file to the server.
Both client and server must implement reliable data transfer using unreliable UDP transport, including
data sequencing, cumulative acknowledgments. We will give you the skeleton code including header setup
and connection setup.
1
UCLA CS 118 Project 2, Spring 2022
2.1 Basic Protocol Specification
You can find the skeleton code from the github repo: https://github.com/CS118S22/Project2. The given
skeleton code cover the implementation of header, basic connection between client and server, and printout
function. Specifically, there are four files:
•server.c implements a server that accepts connection setup and store received files.
•client.c implements a client that initiates connection setup and send a file to the server.
•Makefile helps to compile the server and the client.
•test format.py helps to check the format of client side output.
So you will find the skeleton code covers all functions mentioned in this section. Please read through to
make sure your final implementation STILL conforms to the specification.
2.1.1 Packet Format
•The given header format includes a Sequence Number field, an Acknowledgment Number field, and
ACK , SYN , and FIN flags.
•The header length is exactly 12 bytes, while the design does not use up all 12 bytes, pad zeros to
make it so.
2.1.2 Server Application Specification
The server application MUST be compiled into a binary called server , accepting one command-line argu-
ment:
$ ./server <PORT>
The argument ⟨PORT⟩ is the port number on which server will “listen” on connections (expects UDP
packets to be received). You can assume that the specified p